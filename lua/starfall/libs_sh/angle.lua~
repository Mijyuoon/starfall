SF.Angle = {}

--- Angle Type
-- @shared
local ang_methods, ang_metamethods = SF.Typedef("Angle")
local wrap, unwrap = SF.CreateWrapper(ang_metamethods, true, false, debug.getregistry().Angle)

function SF.DefaultEnvironment.Angle(...)
	return wrap(Angle(...))
end

SF.Angle.Wrap = wrap
SF.Angle.Unwrap = unwrap
SF.Angle.Methods = ang_methods
SF.Angle.Metatable = ang_metamethods

--[=[ Yo man what the fuck?
--- __newindex metamethod
function ang_metamethods.__newindex(t, k, v)
	if k == "p" or k =="y" or k == "r" then
		SF.UnwrapObject(t).__newindex(SF.UnwrapObject(t), k, v)
	else
		rawset(t, k, v)
	end
end

local _p = ang_metamethods.__index
--- __index metamethod
function ang_metamethods.__index(t, k)
	if k == "p" or k =="y" or k == "r" then
		return unwrap(t)[k]
	end
	return _p[k]
end
--]=]

--- __newindex metamethod
function ang_metamethods:__newindex(k, v)
	if k == "p" or k == "y" or k == "r" then
		unwrap(self):__newindex(k, v)
	else
		rawset(self, k, v)
	end
end

local __mt = ang_metamethods.__index
--- __index metamethod
function ang_metamethods:__index(k)
	if k == "p" or k == "y" or k == "r" then
		return unwrap(self):__index(k)
	else
		return __mt[k]
	end
end

--- tostring metamethod.
-- @return string representing the angle.
function ang_metamethods:__tostring()
	return unwrap(self):__tostring()
end

--- __mul metamethod ang1 * ang2.
-- @param a Angle to multiply by.
-- @return resultant angle.
function ang_metamethods:__mul(n)
	SF.CheckType(n, "number")
	return wrap(unwrap(self):__mul(n))
end

--- __unm metamethod -ang.
-- @return resultant angle.
function ang_metamethods:__unm()
	return wrap(unwrap(self):__unm())
end

--- __eq metamethod ang1 == ang2.
-- @param a Angle to check against.
-- @return bool
function ang_metamethods:__eq(a)
	SF.CheckType(a, SF.Types["Angle"])
	return wrap(unwrap(self):__eq(unwrap(a)))
end

--- __add metamethod ang1 + ang2.
-- @param a Angle to add.
-- @return resultant angle.
function ang_metamethods:__add(a)
	SF.CheckType(a, SF.Types["Angle"])
	return wrap(unwrap(self):__add(unwrap(a)))
end

--- __sub metamethod ang1 - ang2.
-- @param a Angle to subtract.
-- @return resultant angle.
function ang_metamethods:__sub(a)
	SF.CheckType(a, SF.Types["Angle"])
	return wrap(unwrap(self):__sub(unwrap(a)))
end


--- Return the Forward Vector(direction the angle points).
-- @return vector normalised.
function ang_methods:getForward()
	return wrap(unwrap(self):Forward())
end

--- Returns if p,y,r are all 0.
-- @return boolean
function ang_methods:isZero()
	return unwrap(self):IsZero()
end

--- Normalise angles eg(0,181,1) ->(0,-179,1).
-- @return nil
function ang_methods:normalize()
	unwrap(self):Normalize()
end

--- Return the Right Vector relative to the angle dir.
-- @return vector normalised.
function ang_methods:getRight()
	return wrap(unwrap(self):Right())
end

--- Rotates the angle around the specified axis by the specified degrees.
-- @param v Axis
-- @param r Number of degrees.
-- @return nil
function ang_methods:rotateAroundAxis(v, r)
	SF.CheckType(v, SF.Types["Vector"])
	SF.CheckType(r, "number")
	unwrap(self):RotateAroundAxis(SF.UnwrapObject(v), r)
end

--- Copies p,y,r from second angle to the first.
-- @param a Angle to copy from.
-- @return nil
function ang_methods:set(a)
	SF.CheckType(a, SF.Types["Angle"])
	unwrap(self):Set(unwrap(a))
end

--- Return the Up Vector relative to the angle dir.
-- @return vector normalised.
function ang_methods:getUp()
	return wrap(unwrap(self):Up())
end

--- Sets p,y,r to 0. This is faster than doing it manually.
-- @return nil
function ang_methods:setZero()
	unwrap(self):Zero()
end